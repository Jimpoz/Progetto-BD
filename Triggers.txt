Viene richiesto di sviluppare un applicativo per la gestione di esami universitari. I docenti possono creare
nuovi esami, ciascuno dei quali richiede il superamento di n ≥ 1 prove. 

//già implementato in BD

Quando tutte le n prove sono state
superate e sono ancora valide, `e possibile registrare il voto. 

//Trigger per superamento
CREATE FUNCTION Is_Passed RETURNS TRIGGER
AS $$
BEGIN
    IF(FALSE=ANY(SELECT stato_superamento
                 FROM prova p
                 WHERE new.idE==p.idE))
        THEN RETURN NULL
    END IF
    RETURN new
END
$$ LANGUAGE PLPGSQL

CREATE TRIGGER Passed
BEFORE UPDATE? OR INSERT
ON registrazione_esame
FOR EACH ROW?
EXECUTE FUNCTION Is_Passed


//Trigger per validità
CREATE FUNCTION Is_Valid RETURNS TRIGGER
AS $$
BEGIN
    //https://www.geeksforgeeks.org/sql-query-to-check-if-date-is-greater-than-today-in-sql/
    IF( GETDATE()> ANY (SELECT p.data_scadenza   
                        FROM prova p
                        WHERE new.idE==p.idE))
                        //se la sottoquery dà più risultati è sbagliata, ma se uso any me li controlla tutti
        THEN RETURN NULL
    END IF
    RETURN new
END
$$ LANGUAGE PLPGSQL

CREATE TRIGGER Valid
BEFORE UPDATE? OR INSERT
ON registrazione_esame
FOR EACH ROW?
EXECUTE FUNCTION Is_Valid

//manca la verbalizzazione

Ogni studente pu`o sostenere una delle prove ad
uno degli appelli.

//lo interpreto come che non posso avere lo stesso studente iscritto allo stesso appello 2 volte, SENZA controllo date
CREATE FUNCTION Secure_Only_One RETURNS TRIGGER
AS $$
BEGIN
    IF(EXISTS(SELECT *
              FROM Appelli a
              WHERE new.idS=a.idS AND new.idP=a.idP))
        THEN RETURN NULL
    END IF
    RETURN new
END
$$ LANGUAGE PLPGSQL

CREATE TRIGGER Only_One
BEFORE INSERT
ON Appelli
FOR EACH ROW
EXECUTE FUNCTION Secure_Only_One

Quando si supera una prova, il suo superamento ha una data che registra quando `e stata
sostenuta e una data che registra la sua scadenza. Dopo la scadenza una prova non `e pi`u valida: rimane
nel sistema, ma dal punto di vista della registrazione `e come se non fosse stata superata.

//trigger creato sopra

Un’altra ragione
di invalidazione di una prova `e il sostenimento della stessa prova ad un appello successivo. Se l’appello pi`u
recente `e superato, allora il voto precedente si invalida e quello nuovo ne prende il posto. Se invece l’appello
pi`u recente non `e superato, la prova precedente viene invalidata e si registra la nuova come un fallimento.

//Trigger sostituizione voto
CREATE FUNCTION Is_Replaced RETURNS TRIGGER
AS $$
BEGIN
    //se trovo la stessa prova registrata per lo stesso studente
    IF(new.idP IN ( SELECT idP
                    FROM Appelli)
        AND new.idS=( SELECT idS
                      FROM Appelli
                      WHERE idP=new.idP))
        //aggiorno solo i valori che effettivamente cambiano e non metto che lo stato di superamento è true, potrebbe essere anche false
        THEN
        UPDATE Appelli
        SET voto=new.voto, stato_superamento=new.stato_superamento
        WHERE idP=new.idP AND idS=new.idS
    END IF
    RETURN new
END
$$ LANGUAGE PLPGSQL

CREATE TRIGGER Sostitution
AFTER INSERT
ON Appelli
FOR EACH STATEMENT
EXECUTE FUNCTION Is_Replaced 

Il sistema deve essere in grado di visualizzare lo stato di studenti (prove valide sostenute, storico delle
prove sostenute...) ed appelli (studenti che hanno superato le diverse prove). 

//dovremmo aggiungere sezioni nel sito o è a posto cosi?

Deve essere possibile ottenere
l’elenco degli studenti che sono in condizione di avere l’esame registrato (ma non lo hanno ancora fatto)
perch`e tutte le n prove sono superate e valide, mostrando per ciascuno le caratteristiche delle prove che
abilitano la registrazione dell’esame.

//dovrebbe essere la sezione verbalizzazione, che è da finalizzare

Vengono forniti alcuni spunti possibili per arricchire lo scenario, senza pretesa di esaustivit`a:
 Ogni prova ha una diversa tipologia (scritto, orale, progetto...) 

//OK

ed un diverso tipo di ricaduta sul
superamento dell’esame (idoneit`a, voto che contribuisce alla media pesata, bonus al voto...). Il docente
deve poter configurare questo aspetto dell’esame, andando a definire i criteri per la valutazione finale.

//abbiamo fatto media pesata, i bonus e l'idoneità forse è da finalizzare?

 E’ possibile definire dei vincoli sulle prove d’esame, richiedendo per esempio che la discussione del
progetto debba essere effettuata solo dopo che l’esame scritto `e stato superato. 

//Possibile trigger

Certe prove d’esame
potrebbero essere opzionali, cio`e lo studente pu`o scegliere se svolgerle o meno, o mutuamente esclusive
con altre, cio`e lo studente deve scegliere una fra pi`u opzioni disponibili.

//Possibile trigger

 Le diverse prove d’esame possono essere gestite da docenti diversi, come nel caso dei compitini. In
questo caso un docente non pu`o interferire con la valutazione data da un altro docente, per`o deve essere
possibile avere visibilit`a dell’esame nel suo complesso.

//OK, questi sono i ruoli

 I compitini potrebbero essere soggetti a regole
speciali (es. essere disponibili solo in un certo appello d’esame).

//Possibile trigger



'''
#check e trigger da aggiungere

//già fatto sopra (mancerebbe la parte della scritta "ins")
se nella lista appelli c'è almeno un stato_superamento = False allora nella verbalizzazione risulta ins

uno studente non può iscriversi al secondo appelli se non ha superato il primo, fare il controllo tramite la data

CREATE FUNCTION 
AS $$
BEGIN
    IF(EXISTS ( SELECT *
                FROM Appelli a JOIN prova p ON a.idP=p.idP
                WHERE a.stato_superamento=FALSE AND p.idP=( SELECT p1.idP
                                                            FROM Appelli a1 JOIN prova p1 ON a1.idP=p1.idP
                                                            WHERE p1.idP=p.idP AND p1.date<>p.date AND a1.idS=a.idS)))
        THEN RETURN NULL
    END IF
    RETURN new
END
$$ LANGUAGE PLPGSQL

CREATE TRIGGER 
BEFORE INSERT OR UPDATE 
ON Appelli
FOR EACH ROW
EXECUTE FUNCTION

//Non ho idea se sia fondato o meno
un esame non può essere eliminato 7 giorni prima della data del primo appello(?) -> da verificare

//Ho guardato la tabella registrazione esame, ha la FK diretta dalla tabella esame, è impossibile che abbia un esame 
//non esistente. Anche in appelli l'idP lo prende da un'altra parte, quindi è sempre impossibile
uno studente non può iscriversi ad un esame che non esiste

//Lo interpreto come che non possono essere registrate diverse prove con lo stesso giorno a uno studente
uno studente non può iscriversi a più esami lo stesso giorno

CREATE FUNCTION Deny_Insert_Double_Date_Test RETURNS TRIGGER
AS $$
BEGIN
    IF(EXISTS ( SELECT *
                FROM prova
                WHERE new.idS=idS AND new.idP<>idP AND new.data=data))
        THEN RETURN NULL
    END IF
    RETURN new
END
$$ LANGUAGE PLPGSQL

CREATE TRIGGER Double_Date_Test
BEFORE INSERT
ON prova
FOR EACH ROW
EXECUTE FUNCTION Deny_Insert_Double_Date_Test

//serve realmente? Comunque non c'è la funzione di cancellarlo
//Lo interpreto come che non posso cancellare un esame se è presente nel registro di un studente
una volta verbalizzato un esame non può essere eliminato dallo studente

CREATE FUNCTION Deny_Delete_Verbalized_Exam RETURNS TRIGGER
AS $$
BEGIN
    IF(EXISTS ( SELECT *
                FROM registrazione_esame
                WHERE old_table.idE=idE))
        THEN INSERT INTO esame(idE,nome,anno_accademico,cfu)
        VALUES(old_table.idE,old_table.nome,old_table.anno_accademico,old_table.cfu)
    END IF
END
$$ LANGUAGE PLPGSQL

CREATE TRIGGER Delete_Verbalized_Exam
AFTER DELETE
ON esame
REFERENCING OLD TABLE AS old_table
FOR EACH STATEMENT
EXECUTE FUNCTION Deny_Delete_Verbalized_Exam

//lo svolgo anche per prova perchè a logica non si può cancellare

CREATE FUNCTION Deny_Delete_Test_Done RETURNS TRIGGER
AS $$
BEGIN
    IF(EXISTS ( SELECT *
                FROM registrazione_esame re JOIN prova p ON re.idE=p.idE
                WHERE old_table.idP=p.idP))
        THEN INSERT INTO prova(idP,tipo_voto,idE,tipo_prova,nome_prova,idD,data,data_scadenza,ora_prova,percentuale)
        VALUES(old_table.idP,old_table.tipo_voto,old_table.idE,old_table.tipo_prova,old_table.nome_prova,old_table.idD,old_table.data,old_table.data_scadenza,old_table.ora_prova,old_table.percentuale)
    END IF
END
$$ LANGUAGE PLPGSQL

CREATE TRIGGER Delete_Test_Done
AFTER DELETE
ON prova
REFERENCING OLD TABLE AS old_table
FOR EACH STATEMENT
EXECUTE FUNCTION Deny_Delete_Test_Done

//manca UNIQUE su idP? 
un docente non può creare 2 prove identiche in 2 esami diversi

CREATE FUNCTION Double_Test_Different_Exam RETURNS TRIGGER
AS $$
BEGIN
    IF(EXISTS ( SELECT *
                FROM prova p
                WHERE new.idP=p.idP AND new.idE<>p.idE))
        THEN RETURN NULL
    END IF
    RETURN new
END
$$ LANGUAGE PLPGSQL

CREATE TRIGGER Double_Test_Different_Exam
BEFORE INSERT OR UPDATE
ON prova
FOR EACH ROW
EXECUTE FUNCTION Deny_Double_Test_Different_Exam

//forse obsoleti
un docente non può creare 2 prove/esami con stessi id

CREATE FUNCTION Is_Test_Double RETURNS TRIGGER
AS $$
BEGIN
    IF(EXISTS(SELECT *
                FROM prova p
                WHERE new.nome_prova=p.nome_prova))
        THEN RETURN NULL
    END IF
    RETURN new
END
$$ LANGUAGE PLPGSQL

CREATE TRIGGER Double_Test_Name
BEFORE INSERT OR UPDATE
ON prova
FOR EACH ROW
EXECUTE FUNCTION Is_Test_Double 

//creazione_esame deve diventare esame
CREATE FUNCTION Is_Exam_Double RETURNS TRIGGER
AS $$
BEGIN
    IF(EXISTS(SELECT *
                FROM esame e
                WHERE new.nome=e.nome))
        THEN RETURN NULL
    END IF
    RETURN new
END
$$ LANGUAGE PLPGSQL

CREATE TRIGGER Double_Exam_Name
BEFORE INSERT OR UPDATE
ON esame
FOR EACH ROW
EXECUTE FUNCTION Is_Exam_Double 

#da aggiungere

'''

//mettere il trigger che una persona non puo iscriversi al secondo appello di una prova senza aver superato il primo